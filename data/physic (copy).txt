layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct object_node
{
	uint object_index;
	uint padding[3];

	
	mat4 translation;
	mat4 translation_inv;
};

struct collision_pair
{
	vec3 position;
	float dummy_1;
	uint a;
	uint b;
	uint dummy_2[2];
};

layout(binding=5) uniform nodes_ubo
{
	object_node 	nodes[OBJECT_NODE_COUNT];
	uint 		nodes_count; 
	uint		nodes_ubo_dummy[3];
};


layout(binding=0) uniform atomic_uint collision_count;

layout(std430, binding=1) buffer collision_ssbo
{
	collision_pair collision[];
};


struct pair
{
	uint a;
	uint b;
};

pair index_to_pair(uint index)
{
	uint n = uint(floor((sqrt(8*index+1)-1)/2));
	uint a = index - (n * (n+1))/2;
	uint b = n + 1;
	pair p;
	p.a = a;
	p.b = b;
	return p;
}

float implicit_cylinder(vec3 p)
{
	float radius = 1.0;
	float height = 1.0;
	vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(radius, height);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));			
}

float distance_cylinder_cylinder(vec3 p, uint a, uint b)
{
	return implicit_cylinder((nodes[a].translation_inv * vec4(p, 1.0)).xyz) + implicit_cylinder((nodes[b].translation_inv * vec4(p, 1.0)).xyz);
}

vec3 gradient_cylinder_cylinder(vec3 p, uint a, uint b)
{
	vec2 step = vec2(0.001, 0);
	return vec3(
		1/(2*step.x)*(distance_cylinder_cylinder(p+step.xyy, a, b) - distance_cylinder_cylinder(p-step.xyy, a, b)),
		1/(2*step.x)*(distance_cylinder_cylinder(p+step.yxy, a, b) - distance_cylinder_cylinder(p-step.yxy, a, b)),
		1/(2*step.x)*(distance_cylinder_cylinder(p+step.yyx, a, b) - distance_cylinder_cylinder(p-step.yyx, a, b))
		);
	
}

float implicit_box(vec3 p){
	vec3 d = vec3(1.0);			
	vec3 q = abs(p) - d;				
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);	
}	

float distance_box_box(vec3 p, uint a, uint b)
{
	return implicit_box((nodes[a].translation_inv * vec4(p, 1.0)).xyz) + implicit_box((nodes[b].translation_inv * vec4(p, 1.0)).xyz);
}

vec3 gradient_box_box(vec3 p, uint a, uint b)
{
	vec2 step = vec2(0.001, 0);
	return vec3(
		1/(2*step.x)*(distance_box_box(p+step.xyy, a, b) - distance_box_box(p-step.xyy, a, b)),
		1/(2*step.x)*(distance_box_box(p+step.yxy, a, b) - distance_box_box(p-step.yxy, a, b)),
		1/(2*step.x)*(distance_box_box(p+step.yyx, a, b) - distance_box_box(p-step.yyx, a, b))
		);
	
}

float implicit_sphere(vec3 p)
{
	return length(p) - 1;
}


float distance_sphere_sphere(vec3 p, uint a, uint b)
{
	return implicit_sphere((nodes[a].translation_inv * vec4(p, 1.0)).xyz) + implicit_sphere((nodes[b].translation_inv * vec4(p, 1.0)).xyz);
}

vec3 gradient_sphere_sphere(vec3 p, uint a, uint b)
{
	vec2 step = vec2(0.001, 0);
	return vec3(
		1/(2*step.x)*(distance_sphere_sphere(p+step.xyy, a, b) - distance_sphere_sphere(p-step.xyy, a, b)),
		1/(2*step.x)*(distance_sphere_sphere(p+step.yxy, a, b) - distance_sphere_sphere(p-step.yxy, a, b)),
		1/(2*step.x)*(distance_sphere_sphere(p+step.yyx, a, b) - distance_sphere_sphere(p-step.yyx, a, b))
		);
	
}


float distance_cylinder_box(vec3 p, uint a, uint b)
{
	return implicit_cylinder((nodes[a].translation_inv * vec4(p, 1.0)).xyz) + implicit_box((nodes[b].translation_inv * vec4(p, 1.0)).xyz);
}

vec3 gradient_cylinder_box(vec3 p, uint a, uint b)
{
	vec2 step = vec2(0.001, 0);
	return vec3(
		1/(2*step.x)*(distance_cylinder_box(p+step.xyy, a, b) - distance_cylinder_box(p-step.xyy, a, b)),
		1/(2*step.x)*(distance_cylinder_box(p+step.yxy, a, b) - distance_cylinder_box(p-step.yxy, a, b)),
		1/(2*step.x)*(distance_cylinder_box(p+step.yyx, a, b) - distance_cylinder_box(p-step.yyx, a, b))
		);
	
}




void main()
{
	uint pair_index = gl_GlobalInvocationID.x; 
	pair p = index_to_pair(pair_index);
	
	uint intersection = 0;
	uint switch_a_b = 0;
	vec3 minimal = vec3(0);
	if(nodes[p.a].object_index == 0 && nodes[p.b].object_index == 0)
	{
		for(uint i = 0; i < 32; i++)
		{
			vec3 grad = gradient_cylinder_cylinder(minimal, p.a, p.b);
			minimal = minimal - grad;
			if(distance_cylinder_cylinder(minimal, p.a, p.b) < 0.0){
				intersection =  1;
				break;
			}
		}
	}
	else if(nodes[p.a].object_index == 1 && nodes[p.b].object_index == 1)
	{
		for(uint i = 0; i < 32; i++)
		{
			vec3 grad = gradient_box_box(minimal, p.a, p.b);
			minimal = minimal - grad;
			if(distance_box_box(minimal, p.a, p.b) < 0.0){
				intersection =  1;
				break;
			}
		}
	}
	else if(nodes[p.a].object_index == 2 && nodes[p.b].object_index == 2)
	{
		for(uint i = 0; i < 32; i++)
		{
			vec3 grad = gradient_sphere_sphere(minimal, p.a, p.b);
			minimal = minimal - grad;
			if(distance_sphere_sphere(minimal, p.a, p.b) < 0.0){
				intersection =  1;
				break;
			}
		}
	}
	else if(nodes[p.a].object_index == 0 && nodes[p.b].object_index == 1)
	{
		for(uint i = 0; i < 32; i++)
		{
			vec3 grad = gradient_cylinder_box(minimal, p.a, p.b);
			minimal = minimal - grad;
			if(distance_cylinder_box(minimal, p.a, p.b) < 0.0){
				intersection =  1;
				break;
			}
		}
	
	}
	else if(nodes[p.a].object_index == 0 && nodes[p.b].object_index == 1)
	{
	
	
	}
	
	
	
	if(intersection > 0){
		uint index = atomicCounterIncrement(collision_count);	
		collision[index].a = p.a;
		collision[index].b = p.b;
		collision[index].position = minimal;
	}
}


