#version 430 core

layout(local_size_x=1, local_size_y=1, local_size_z=1) in;

struct sphere_instance
{
	mat4 translation;
	mat4 translation_inv;
	vec3 color;
	float radius;
};

struct cylinder_instance
{
	mat4 translation;

	mat4 translation_inv;

	vec3 color;

	/* radius of each cylinder  */
	float radius; 

	/* height of cylinder */
	float height;
	
	/* Required padding */
	float dummy[3];
};


struct box_instance
{
	mat4 translation;
	
	mat4 translation_inv;
	
	vec3 color; 
	
	float padding1;
	
	/* box dimension */	
	vec3 dimension;

	float padding2;
};

struct light_instance
{
	vec3 position;
	float padding1;
	vec3 color;
	float padding2;
};


layout(rgba32f, binding=0) uniform restrict image2D color;
layout(rgba32f, binding=1) uniform restrict image2D position;
layout(rgba32f, binding=2) uniform restrict image2D normal;
layout(rgba32f, binding=3) uniform restrict image2D composed;

layout(binding=0, std430) readonly restrict buffer sphere_ssbo
{
	sphere_instance spheres[];
};


layout(binding=1, std430) readonly restrict buffer cylinder_ssbo
{
	cylinder_instance cylinders[];
};


layout(binding=2, std430) readonly restrict buffer box_ssbo
{
	box_instance boxes[];
};


layout(binding=3, std430) readonly restrict buffer light_ssbo
{
	light_instance lights[];
};





uniform scene
{
	mat4 view;
	mat4 view_inv;
};

float sphere(vec3 p, float r)
{
	return length(p) - r;
}


float cylinder(vec3 p, float height, float radius)
{
	vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(radius, height);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));			
}

float box(vec3 p, vec3 d){			
	vec3 q = abs(p) - d;				
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);	
}	

struct distance_result
{
	vec4 p;
	float min;
};

distance_result distance(vec4 p, float t_max)
{
	
	vec4 p_res;
	float min_t = t_max;
	
	for(int i = 0; i < spheres.length(); i++)
	{
		vec4 e = spheres[i].translation_inv*p;
		float t = sphere(e.xyz, spheres[i].radius);
		if(t < min_t){
			p_res = spheres[i].translation*p;
			min_t = t;
		}
	}
	
	for(int i = 0; i < cylinders.length(); i++)
	{
		vec4 e = cylinders[i].translation_inv*p;
		float t = cylinder(e.xyz, cylinders[i].radius, cylinders[i].height);
		if(t < min_t){
			p_res = cylinders[i].translation*p;
			min_t = t;
		}
	}
	
	
	for(int i = 0; i < boxes.length(); i++)
	{
		vec4 e = boxes[i].translation_inv*p;
		float t = box(e.xyz, boxes[i].dimension);
		if(t < min_t){
			p_res = boxes[i].translation*p;
			min_t = t;
		}
	}
	distance_result result;
	result.p = p_res;
	result.min = min_t;
	return result;
	
}

void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	vec3 n = imageLoad(normal, coord).xyz;
	vec3 p = imageLoad(position, coord).xyz;
	vec3 c = imageLoad(color, coord).xyz;
	
	vec3 result = vec3(0.0);
	for(int j = 0; j < lights.length(); j++)
	{
		vec3 light_pos = lights[j].position;
		vec3 light_color = lights[j].color;
		
		float len = length(p - light_pos);
		vec3 light_dir = (p-light_pos)/len;
		float diff = max(dot(n, light_dir), 0.0); 
		vec3 diffuse = diff * light_color;
		
		
		float t_max = 100.0;
		float t = 0.0;
		
		distance_result d_res; 
		for(int i = 0; i < 32; i++)
		{
			d_res = distance((vec4(light_pos, 1.0) + vec4(light_dir*t, 1.0)), t_max);
			if(d_res.min < 0.01)
			{
				break;
			}
			t = t + d_res.min;
		}
		
		if(t > len-2)
		{
			result = result + diffuse*c;
		}
	}
	imageStore(composed, coord, vec4(result, 0.0));;
	
}
